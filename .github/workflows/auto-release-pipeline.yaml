name: Auto Release Pipeline

on:
  push:
    branches: [develop]
  pull_request:
    branches: [develop]
    types: [closed]
  repository_dispatch:
    types: [dependency-update-tests]

env:
  GO_VERSION: 'stable'

jobs:
  test-full-suite:
    runs-on: ubuntu-latest
    services:
      rabbitmq:
        image: rabbitmq:4-management
        env:
          RABBITMQ_DEFAULT_USER: guest
          RABBITMQ_DEFAULT_PASS: guest
        ports:
          - 5672:5672
          - 15672:15672
        options: >-
          --health-cmd "rabbitmq-diagnostics -q ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    outputs:
      tests_passed: ${{ steps.test-result.outputs.passed }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: develop

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/go-build
            ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}
          restore-keys: |
            ${{ runner.os }}-go-

      - name: Install dependencies
        run: go mod download

      - name: Wait for RabbitMQ
        run: |
          echo "Waiting for RabbitMQ to be ready..."
          for i in {1..30}; do
            if curl -f http://localhost:15672/api/overview --user guest:guest; then
              echo "RabbitMQ is ready!"
              break
            fi
            echo "Waiting for RabbitMQ... attempt $i"
            sleep 2
          done

      - name: Enable RabbitMQ streams plugin
        run: |
          docker exec $(docker ps -q --filter ancestor=rabbitmq:4-management) rabbitmq-plugins enable rabbitmq_stream

      - name: Run linting
        run: |
          go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
          golangci-lint run

      - name: Run tests with race detection
        run: |
          go test -race -v ./...

      - name: Run integration tests
        run: |
          go test -race -v -tags=integration ./...

      - name: Generate test coverage
        run: |
          go test -race -coverprofile=coverage.out ./...
          go tool cover -func=coverage.out

      - name: Set test result
        id: test-result
        run: |
          echo "passed=true" >> $GITHUB_OUTPUT

  auto-merge-to-main:
    needs: test-full-suite
    if: |
      needs.test-full-suite.outputs.tests_passed == 'true' &&
      (github.event_name == 'push' ||
       (github.event_name == 'pull_request' && github.event.pull_request.merged == true) ||
       github.event_name == 'repository_dispatch')
    runs-on: ubuntu-latest

    outputs:
      release_created: ${{ steps.merge-result.outputs.release_created }}
      new_version: ${{ steps.merge-result.outputs.new_version }}

    steps:
      - name: Checkout develop
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 0
          token: ${{ secrets.CLOUDRESTY_GITBOT_PAT || secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Get current version
        id: current-version
        run: |
          # Get the latest tag
          LATEST_TAG=$(git tag -l "v*" | sort -V | tail -1)
          if [ -z "$LATEST_TAG" ]; then
            LATEST_TAG="v1.0.0"
          fi
          echo "current_version=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Current version: $LATEST_TAG"

      - name: Calculate next version
        id: next-version
        run: |
          CURRENT="${{ steps.current-version.outputs.current_version }}"

          # Remove 'v' prefix and split version
          VERSION=${CURRENT#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # Check commit messages for version bump type
          COMMITS=$(git log --oneline $(git merge-base HEAD main)..HEAD)

          if echo "$COMMITS" | grep -i "breaking\|major"; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif echo "$COMMITS" | grep -i "feat\|feature\|minor"; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEW_VERSION"

      - name: Merge develop to main
        run: |
          git checkout main
          git pull origin main
          git merge develop --no-edit
          git push origin main

      - name: Create and push tag
        id: merge-result
        run: |
          NEW_VERSION="${{ steps.next-version.outputs.new_version }}"

          # Create annotated tag
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION

          Auto-generated release with dependency updates and bug fixes.

          Changes since last release:
          $(git log --oneline $(git tag -l "v*" | sort -V | tail -2 | head -1)..HEAD)"

          git push origin "$NEW_VERSION"

          echo "release_created=true" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

  create-github-release:
    needs: [test-full-suite, auto-merge-to-main]
    if: needs.auto-merge-to-main.outputs.release_created == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout main
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          NEW_VERSION="${{ needs.auto-merge-to-main.outputs.new_version }}"
          PREV_VERSION=$(git tag -l "v*" | sort -V | tail -2 | head -1)

          if [ -z "$PREV_VERSION" ]; then
            PREV_VERSION="v1.0.0"
          fi

          echo "Generating changelog from $PREV_VERSION to $NEW_VERSION"

          # Generate changelog
          CHANGELOG="## What's Changed\n\n"

          # Get commits between versions
          COMMITS=$(git log --oneline $PREV_VERSION..HEAD)

          # Categorize commits
          FEATURES=$(echo "$COMMITS" | grep -i "feat\|feature" || true)
          FIXES=$(echo "$COMMITS" | grep -i "fix\|bug" || true)
          CHORES=$(echo "$COMMITS" | grep -i "chore\|deps" || true)

          if [ ! -z "$FEATURES" ]; then
            CHANGELOG="${CHANGELOG}### âœ¨ New Features\n"
            echo "$FEATURES" | while read line; do
              CHANGELOG="${CHANGELOG}- $line\n"
            done
            CHANGELOG="${CHANGELOG}\n"
          fi

          if [ ! -z "$FIXES" ]; then
            CHANGELOG="${CHANGELOG}### Bug Fixes\n"
            echo "$FIXES" | while read line; do
              CHANGELOG="${CHANGELOG}- $line\n"
            done
            CHANGELOG="${CHANGELOG}\n"
          fi

          if [ ! -z "$CHORES" ]; then
            CHANGELOG="${CHANGELOG}### Maintenance\n"
            echo "$CHORES" | while read line; do
              CHANGELOG="${CHANGELOG}- $line\n"
            done
            CHANGELOG="${CHANGELOG}\n"
          fi

          CHANGELOG="${CHANGELOG}### Test Results\n"
          CHANGELOG="${CHANGELOG}- All tests passing\n"
          CHANGELOG="${CHANGELOG}- Race condition detection clean\n"
          CHANGELOG="${CHANGELOG}- Integration tests successful\n"
          CHANGELOG="${CHANGELOG}- Linting passed\n\n"

          CHANGELOG="${CHANGELOG}**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREV_VERSION...$NEW_VERSION"

          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo -e "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ needs.auto-merge-to-main.outputs.new_version }}"
          CHANGELOG="${{ steps.changelog.outputs.changelog }}"
          
          echo "Creating GitHub release $NEW_VERSION..."
          
          gh release create "$NEW_VERSION" \
            --title "Release $NEW_VERSION" \
            --notes "$CHANGELOG" \
            --generate-notes \
            --latest

          echo "Release $NEW_VERSION created successfully"

  notify-success:
    needs: [test-full-suite, auto-merge-to-main, create-github-release]
    if: always() && needs.auto-merge-to-main.outputs.release_created == 'true'
    runs-on: ubuntu-latest

    steps:
      - name: Notify successful release
        run: |
          echo "Successfully created release ${{ needs.auto-merge-to-main.outputs.new_version }}"
          echo "Release available at: https://github.com/${{ github.repository }}/releases/tag/${{ needs.auto-merge-to-main.outputs.new_version }}"
